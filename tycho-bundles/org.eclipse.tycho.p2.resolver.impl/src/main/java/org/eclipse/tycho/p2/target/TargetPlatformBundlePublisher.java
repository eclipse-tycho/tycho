/*******************************************************************************
 * Copyright (c) 2011 SAP AG and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    SAP AG - initial API and implementation
 *******************************************************************************/
package org.eclipse.tycho.p2.target;

import java.io.File;
import java.io.OutputStream;
import java.net.URI;
import java.util.Collection;
import java.util.Set;

import org.eclipse.core.runtime.AssertionFailedException;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.equinox.p2.core.ProvisionException;
import org.eclipse.equinox.p2.metadata.IInstallableUnit;
import org.eclipse.equinox.p2.publisher.IPublisherAction;
import org.eclipse.equinox.p2.publisher.IPublisherInfo;
import org.eclipse.equinox.p2.publisher.Publisher;
import org.eclipse.equinox.p2.publisher.PublisherInfo;
import org.eclipse.equinox.p2.publisher.PublisherResult;
import org.eclipse.equinox.p2.publisher.eclipse.BundlesAction;
import org.eclipse.equinox.p2.repository.artifact.IArtifactDescriptor;
import org.eclipse.equinox.p2.repository.artifact.IArtifactRepository;
import org.eclipse.equinox.p2.repository.artifact.IFileArtifactRepository;
import org.eclipse.equinox.p2.repository.artifact.spi.ArtifactDescriptor;
import org.eclipse.tycho.core.facade.MavenLogger;
import org.eclipse.tycho.p2.impl.publisher.MavenPropertiesAdvice;
import org.eclipse.tycho.p2.impl.publisher.repo.TransientArtifactRepository;
import org.eclipse.tycho.p2.maven.repository.AbstractMavenArtifactRepository;
import org.eclipse.tycho.p2.maven.repository.Activator;
import org.eclipse.tycho.p2.metadata.IArtifactFacade;
import org.eclipse.tycho.p2.repository.LocalRepositoryReader;
import org.eclipse.tycho.p2.repository.RepositoryLayoutHelper;
import org.eclipse.tycho.p2.repository.RepositoryReader;
import org.eclipse.tycho.p2.util.StatusTool;
import org.eclipse.tycho.repository.p2base.artifact.provider.IRawArtifactFileProvider;
import org.eclipse.tycho.repository.p2base.artifact.provider.streaming.ArtifactSinkException;
import org.eclipse.tycho.repository.p2base.artifact.provider.streaming.IArtifactSink;
import org.eclipse.tycho.repository.p2base.artifact.provider.streaming.IRawArtifactSink;

@SuppressWarnings("restriction")
public class TargetPlatformBundlePublisher {

    private final MavenLogger logger;
    private final PublishedBundlesArtifactRepository publishedArtifacts;

    public TargetPlatformBundlePublisher(File localMavenRepositoryRoot, MavenLogger logger) {
        this.publishedArtifacts = new PublishedBundlesArtifactRepository(localMavenRepositoryRoot);
        this.logger = logger;
    }

    // for testing
    TargetPlatformBundlePublisher(RepositoryReader localMavenRepoProvider, MavenLogger logger) {
        this.publishedArtifacts = new PublishedBundlesArtifactRepository(localMavenRepoProvider);
        this.logger = logger;
    }

    /**
     * Generate p2 data for an artifact, if the artifact is an OSGI bundle.
     * <p>
     * The p2 metadata produced by this method is only determined by the artifact, and the function
     * used for this conversion must not change (significantly) even in future versions. This is
     * required because the resulting metadata can be included in p2 repositories built by Tycho,
     * and hence may be propagated into the p2 universe. Therefore the metadata generated by this
     * method shall fulfil the basic assumption of p2 that ID+version uniquely identifies a
     * unit/artifact. Assuming that distinct bundle artifacts specify unique ID+versions in their
     * manifest (which should be mostly true), and the p2 BundlesAction used in the implementation
     * doesn't change significantly (which can also be assumed), these conditions specified above a
     * met.
     * </p>
     * <p>
     * In slight deviation on the principles described in the previous paragraph, the implementation
     * adds GAV properties to the generated IU. This is justified by the potential benefits of
     * tracing the origin of artifact.
     * </p>
     * 
     * @param mavenArtifact
     *            An artifact in local file system.
     * @return the p2 metadata of the artifact, or <code>null</code> if the artifact isn't a valid
     *         OSGi bundle.
     */
    IInstallableUnit attemptToPublishBundle(IArtifactFacade mavenArtifact) {
        if (!isAvailableAsLocalFile(mavenArtifact)) {
            // this should have been ensured by the caller
            throw new IllegalArgumentException("Not an artifact file: " + mavenArtifact.getLocation());
        }
        if (isCertainlyNoBundle(mavenArtifact)) {
            return null;
        }

        PublisherRun publisherRun = new PublisherRun(mavenArtifact);
        IStatus status = publisherRun.execute();

        if (!status.isOK()) {
            /**
             * If publishing of a jar fails, it is simply not added to the resolution context. The
             * BundlesAction already ignores non-bundle JARs silently, so an error status here
             * indicates a caught exception that we at least want to see.
             */
            logger.warn(StatusTool.collectProblems(status), status.getException());
        }

        IInstallableUnit publishedIU = publisherRun.getPublishedUnitIfExists();
        if (publishedIU != null) {
            IArtifactDescriptor publishedArtifact = publisherRun.getPublishedArtifactDescriptor();
            publishedArtifacts.addDescriptor(publishedArtifact, mavenArtifact);
        }

        return publishedIU;
    }

    private boolean isAvailableAsLocalFile(IArtifactFacade artifact) {
        File localLocation = artifact.getLocation();
        return localLocation != null && localLocation.isFile();
    }

    private boolean isCertainlyNoBundle(IArtifactFacade artifact) {
        return !artifact.getLocation().getName().endsWith(".jar");
    }

    IArtifactRepository getArtifactRepoOfPublishedBundles() {
        return publishedArtifacts;
    }

    private static class PublisherRun {

        private final IArtifactFacade mavenArtifact;

        private PublisherInfo publisherInfo;
        private TransientArtifactRepository collectedDescriptors;
        private PublisherResult publisherResult;

        PublisherRun(IArtifactFacade artifact) {
            this.mavenArtifact = artifact;
        }

        IStatus execute() {
            publisherInfo = new PublisherInfo();
            enableArtifactDescriptorCollection();
            enableUnitAnnotationWithGAV();

            BundlesAction bundlesAction = new BundlesAction(new File[] { mavenArtifact.getLocation() });
            IStatus status = executePublisherAction(bundlesAction);
            return status;
        }

        private void enableArtifactDescriptorCollection() {
            publisherInfo.setArtifactOptions(IPublisherInfo.A_INDEX);
            collectedDescriptors = new TransientArtifactRepository();
            publisherInfo.setArtifactRepository(collectedDescriptors);
        }

        private void enableUnitAnnotationWithGAV() {
            MavenPropertiesAdvice advice = new MavenPropertiesAdvice(mavenArtifact.getGroupId(),
                    mavenArtifact.getArtifactId(), mavenArtifact.getVersion(), mavenArtifact.getClassifier());
            publisherInfo.addAdvice(advice);
        }

        private IStatus executePublisherAction(BundlesAction action) {
            IPublisherAction[] actions = new IPublisherAction[] { action };
            publisherResult = new PublisherResult();
            return new Publisher(publisherInfo, publisherResult).publish(actions, null);
        }

        IInstallableUnit getPublishedUnitIfExists() {
            Collection<IInstallableUnit> units = publisherResult.getIUs(null, null);
            if (units.isEmpty()) {
                // the BundlesAction simply does not create any IUs if the JAR is not a bundle
                return null;
            } else if (units.size() == 1) {
                return units.iterator().next();
            } else {
                throw new AssertionFailedException("BundlesAction produced more than one IU for "
                        + mavenArtifact.getLocation());
            }
        }

        IArtifactDescriptor getPublishedArtifactDescriptor() {
            Set<IArtifactDescriptor> descriptors = collectedDescriptors.getArtifactDescriptors();
            if (descriptors.isEmpty()) {
                throw new AssertionFailedException("BundlesAction did not create an artifact entry for "
                        + mavenArtifact.getLocation());
            } else if (descriptors.size() == 1) {
                return descriptors.iterator().next();
            } else {
                throw new AssertionFailedException("BundlesAction created more than one artifact entry for "
                        + mavenArtifact.getLocation());
            }
        }
    }

    // TODO 393004 use a different base class
    private static class PublishedBundlesArtifactRepository extends AbstractMavenArtifactRepository implements
            IFileArtifactRepository, IRawArtifactFileProvider {

        PublishedBundlesArtifactRepository(File localMavenRepositoryRoot) {
            this(new LocalRepositoryReader(localMavenRepositoryRoot));
        }

        PublishedBundlesArtifactRepository(RepositoryReader artifactProvider) {
            super(Activator.getProvisioningAgent(), null, artifactProvider);
            super.setLocation(URI.create("memory:" + getClass().getName() + "@"
                    + Integer.toHexString(System.identityHashCode(this))));
        }

        @Override
        public boolean isModifiable() {
            // allow artifacts to be added...
            return true;
        }

        @Override
        public OutputStream getOutputStream(IArtifactDescriptor descriptor) throws ProvisionException {
            // ... but only artifacts already in the local Maven repositories - for these only a descriptor is added 
            throw new AssertionFailedException("Unexpected method call");
        }

        void addDescriptor(IArtifactDescriptor descriptor, IArtifactFacade mavenArtifact) {
            addDescriptor(createDescriptorWithGAV(descriptor, mavenArtifact));
        }

        private static ArtifactDescriptor createDescriptorWithGAV(IArtifactDescriptor descriptor,
                IArtifactFacade mavenArtifact) {
            ArtifactDescriptor internalDescriptor = new ArtifactDescriptor(descriptor);
            // set the GAV properties so that the artifact is read from the GAV location
            // TODO join all the artifact addressing logic of AbstractMavenArtifactRepository somewhere
            internalDescriptor.setProperty(RepositoryLayoutHelper.PROP_GROUP_ID, mavenArtifact.getGroupId());
            internalDescriptor.setProperty(RepositoryLayoutHelper.PROP_ARTIFACT_ID, mavenArtifact.getArtifactId());
            internalDescriptor.setProperty(RepositoryLayoutHelper.PROP_VERSION, mavenArtifact.getVersion());
            String classifier = mavenArtifact.getClassifier();
            if (classifier != null && classifier.length() > 0) {
                internalDescriptor.setProperty(RepositoryLayoutHelper.PROP_CLASSIFIER, classifier);
            }
            internalDescriptor.setProperty(RepositoryLayoutHelper.PROP_EXTENSION, null);
            return internalDescriptor;
        }

        public IStatus getArtifact(IArtifactSink sink, IProgressMonitor monitor) throws ArtifactSinkException {
            // TODO 393004 inherit this from a base class
            return null;
        }

        public IStatus getRawArtifact(IRawArtifactSink sink, IProgressMonitor monitor) throws ArtifactSinkException {
            // TODO 393004 use a different base class
            return null;
        }

    }
}
