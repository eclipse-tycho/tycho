/*******************************************************************************
 * Copyright (c) 2011, 2013 SAP SE and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    SAP SE - initial API and implementation
 *******************************************************************************/
package org.eclipse.tycho.p2.target;

import java.io.File;
import java.util.LinkedHashMap;
import java.util.Map;

import org.eclipse.equinox.p2.metadata.IInstallableUnit;
import org.eclipse.tycho.core.shared.MavenLogger;
import org.eclipse.tycho.p2.metadata.IArtifactFacade;
import org.eclipse.tycho.repository.p2base.artifact.provider.IRawArtifactFileProvider;

public class TargetPlatformBundlePublisherService {

    private final MavenLogger logger;
    private TargetPlatformBundlePublisher targetPlatformBundlePublisher;
    private static final int ARTIFACT_CACHE_SIZE = 10000;
    /**
     * Cache containing {@link IInstallableUnit} for a given {@link IArtifactFacade}. During
     * profiling Tyhco it turned out, that turning normal maven artifacts into installable p2
     * artifacts takes a lot of time. Especially calculating MD5 hash for an artifact. In case of a
     * multimodule project the same artifact will be published several times. This makes no sense.
     * Since these installable artifacts are examined before the actual maven build happens, it is
     * really not likely that these maven artifacts change during the whole build. So I cache them
     * here. The actual items are only metadata, so the cache will not be that big. Just to make it
     * sure the cache is a {@link LinkedHashMap} with limited capacity.
     */
    private static final Map<IArtifactFacade, IInstallableUnit> installableUnitCache = new CacheMap();

    public TargetPlatformBundlePublisherService(File localMavenRepositoryRoot, MavenLogger logger) {
        this.targetPlatformBundlePublisher = new TargetPlatformBundlePublisher(localMavenRepositoryRoot, logger);
        this.logger = logger;
    }

    /**
     * Generate p2 data for an artifact, if the artifact is an OSGI bundle.
     * <p>
     * The p2 metadata produced by this method is only determined by the artifact, and the function
     * used for this conversion must not change (significantly) even in future versions. This is
     * required because the resulting metadata can be included in p2 repositories built by Tycho,
     * and hence may be propagated into the p2 universe. Therefore the metadata generated by this
     * method shall fulfill the basic assumption of p2 that ID+version uniquely identifies a
     * unit/artifact. Assuming that distinct bundle artifacts specify unique ID+versions in their
     * manifest (which should be mostly true), and the p2 BundlesAction used in the implementation
     * doesn't change significantly (which can also be assumed), these conditions specified above a
     * met.
     * </p>
     * <p>
     * In slight deviation on the principles described in the previous paragraph, the implementation
     * adds GAV properties to the generated IU. This is justified by the potential benefits of
     * tracing the origin of artifact.
     * </p>
     * 
     * @param mavenArtifact
     *            An artifact in local file system.
     * @return the p2 metadata of the artifact, or <code>null</code> if the artifact isn't a valid
     *         OSGi bundle.
     */
    IInstallableUnit attemptToPublishBundle(IArtifactFacade mavenArtifact) {
        IInstallableUnit publishedIU = null;
        IArtifactFacade artifactCacheKey = new ArtifactFacadeKey(mavenArtifact);
        synchronized (installableUnitCache) {
            /*
             * I really don't think that Tycho likes multithreaded build. But in case if it still
             * used multithreaded just to prevent race conditions we simply serialize these
             * requests.
             */
            publishedIU = installableUnitCache.get(artifactCacheKey);
            if (publishedIU == null) {
                logger.debug("No cached published artifact for " + mavenArtifact + "(" + mavenArtifact.getGroupId()
                        + ":" + mavenArtifact.getArtifactId() + ":" + mavenArtifact.getClassifier() + ":"
                        + mavenArtifact.getVersion() + ")");

                publishedIU = targetPlatformBundlePublisher.attemptToPublishBundle(mavenArtifact);

                installableUnitCache.put(artifactCacheKey, publishedIU);
            }
        }
        return publishedIU;
    }

    IRawArtifactFileProvider getArtifactRepoOfPublishedBundles() {
        return targetPlatformBundlePublisher.getArtifactRepoOfPublishedBundles();
    }

    /**
     * Simple access order {@link LinkedHashMap} based cache.
     * 
     * @author liptak
     */
    private static final class CacheMap extends LinkedHashMap<IArtifactFacade, IInstallableUnit> {
        private static final long serialVersionUID = 1L;
        private static final float LOAD_FACTOR = 0.75f;
        private static final int INITIAL_CAPACITY = 32;
        private static final boolean ACCESS_ORDER = true;

        public CacheMap() {
            super(INITIAL_CAPACITY, LOAD_FACTOR, ACCESS_ORDER);
        }

        protected boolean removeEldestEntry(Map.Entry<IArtifactFacade, IInstallableUnit> eldest) {
            return size() > ARTIFACT_CACHE_SIZE;
        }
    }
}
